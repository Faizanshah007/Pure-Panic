ConstantBuffer cameraMatrix
{
	column_major matrix projMatrix;
	column_major matrix viewMatrix;
}


ConstantBuffer viewProjMatrix{
	column_major matrix viewProjMatrix;
};

ConstantBuffer invProjMatrix{
	float4x4 invProjMatrix;
};

ConstantBuffer lightPos
{
	float3 LightPos;
};

ConstantBuffer lightRadius{
	float LightRadius;
};

ConstantBuffer lightColour{
	float4 LightColour;
};

ConstantBuffer hasTexture
{
	int m_hasTexture;
};

ConstantBuffer hasPaintMask
{
	int m_usePaintMask;
};

SamplerState samp0 : register(s0);

Texture2D colorMap : register( t0 );

SamplerState samp1: register(s2);

Texture2D mask : register( t2 );

struct VS_OUTPUT
{
	float4 Position		: S_POSITION;
	float2 UV			: TEXCOORD0;
	float3 Normal		: NORMAL;
	float3 WorldPos		: TANGENT;
	float4 Color		: COLOR0;
};

float4 main(VS_OUTPUT In) : S_TARGET_OUTPUT
{
	float3  incident = normalize ( LightPos - In.WorldPos );
	float lambert  = max (0.0 , dot ( incident , In.Normal )) * 0.9; 
	
	float3 viewDir = mul(transpose(float3x3(viewMatrix)),normalize(In.Position.xyz));
	float3 halfDir = normalize ( incident + viewDir );

	float rFactor = max (0.0 , dot(halfDir , In.Normal ));
	float sFactor = pow ( rFactor , 80.0 );

	float4 albedo = In.Color;

	if (albedo.a < 0.01){
		discard;
	}

	if (m_hasTexture == 1){
		albedo *= colorMap.Sample(samp1, In.UV.xy);
	}

	if (m_usePaintMask == 1){
		float4 maskAlbedo = mask.Sample(samp1, In.UV.xy);
		if (maskAlbedo.r > 0.01 || maskAlbedo.g > 0.01 || maskAlbedo.b > 0.01){
			albedo.rgb = maskAlbedo.rgb;
		}
	}

	albedo.rgb = pow(albedo.rgb, float3(2.2));

	float4 colour = albedo * 0.05f;
	colour.rgb += albedo.rgb * LightColour.rgb * lambert;
	colour.rgb += LightColour.rgb * sFactor;
	colour.rgb = pow(colour.rgb, float3(1.0 / 2.2f));
	colour.a = albedo.a;

	return colour;
}  